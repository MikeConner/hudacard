-# Display running game, after bet placed
-# Displayed for a "new" game -- no bet yet
.container
  %section.games-hero
    .row
      - range = @game.user.bet_range
      = hidden_field_tag :min_bet, range[:min]
      = hidden_field_tag :max_bet, range[:max]
      = render :partial => 'games/sidebar'
      .large-8.columns
        .game-container
          .row
            .large-12.columns
              - for i in 1..5 do
                .large-2.columns.cardarea
                  .card.card-back{:id => "card#{i}"}
                  %cardfront{:id => "seq#{i}", :class => "card card-#{@cards[i-1].value}-#{@cards[i-1].suit.downcase}"}
                  = hidden_field_tag "suit#{i}", "#{@cards[i-1].suit.downcase}"
                  = hidden_field_tag "value#{i}", "#{@cards[i-1].value}"
              .small-6.large-6.columns.panel
                .hash#hash
                  Key for this game:
                  = @game.security_code
              .small-6.large-6.columns.panel
                MD5 Hash for next game:
                = @new_game.game_key
        .game-controls
          = form_for @new_game do |f|
            = render :partial => 'games/bet_fields', :locals => { :f => f, :game => @new_game }
= render :partial => 'games/qrcode'

:javascript
  var BALANCE_SPEED = 3000;

  $(document).ready(function() {
  var wait = 1000;
  
  // Result box WIN/LOSE
  $('#winbox').hide()
  $('#hash').hide();
  
  // Fronts of the cards
  $('cardfront').hide();
  
  // Mid-game notes
  $('.midgame').hide();

  // Show first card
  $('#seq1').show();
  drawCard($('#seq1'), changeCard($('#value1').val()), $('#suit1').val(), 160);
  $('#card1').hide();
  $('#announcer').delay(wait).fadeOut(0);
  for (var idx = 2; idx <= 5; idx++) {
    drawCard($('#seq' + idx), changeCard($('#value' + idx).val()), $('#suit'+idx).val(), 160);
    $('#seq' + idx).delay(wait * (idx - 1)).fadeIn(wait);
    $('#card' + idx).delay(wait * (idx - 1)).fadeOut(0);
  }

  for (var idx = 2; idx <= 4; idx++) {
    $('#announcer' + idx).delay(wait * (idx - 1)).fadeIn(wait);
    $('#announcer' + idx).delay(0).fadeOut(0);    
  }
  
    $('#winbox').delay(wait * 4).fadeIn(wait);
    $('#hash').delay(wait * 4).fadeIn(wait);
    
    setTimeout(updateBalance, wait * 5);
  });

  function updateBalance() {
    var satBal = parseInt($('#satoshibalance').text());
    var satPay = parseInt($('#payout').val());
    var btcBalNew = (satPay + satBal) / 100000;
         
    if (!(isNaN(satPay) || (0 == satBal))) {
        $('#btcbalance').text(btcBalNew + " mà¸¿");
        if (satPay < 0){
          $('#satoshibalance').text(satBal + satPay);
        }
        else {
          $('#satoshibalance').countTo({
                      from: satBal,
                      to: satBal + satPay,
                      speed: BALANCE_SPEED,
                      refreshInterval: 50,
                      onComplete: function(value) { console.debug(this);}
                    });
        }
    }
  }
